using FluentResults;
using ConsoleValidator.Messages;
using Google.Protobuf.Reflection;
using ProtoValidate;

namespace ConsoleValidator.Validators;

public class ProtoValidator {

    // flag to indicate if the validator should return on the first error (true) or validate all the fields and return all the errors in the message (false).
    private const bool _failFast = false;

    private readonly Validator _validator;

    public ProtoValidator() {
        var validatorOptions = new ProtoValidate.ValidatorOptions() {
            // This setting is used to configure if it loads your validation descriptors upon creation of the validator.
            // True will load on creation
            // False will defer loading the validator until first run of the validation logic for that type.
            PreLoadDescriptors = false,

            // This setting will cause a compilation exception to be thrown if the message type you are validating hasn't been pre-loaded using the file descriptor list.
            DisableLazy = false,

            //register your file descriptors generated by Google.Protobuf library for your compiled .proto files
            FileDescriptors = new List<FileDescriptor>() {
                //your list of Protobuf File Descriptors here
                User.Descriptor.File
            }
        };

        //Instantiate the validator.  You should cache the validator for reuse.
        _validator = new ProtoValidate.Validator(validatorOptions);
    }

    public Result ValidateUser(User user, bool failFast = _failFast)
    {
        // //validate the message
        var violations = _validator.Validate(user, failFast);

        // //the violations contains the validation errors.
        var hasViolations = violations.Violations.Count > 0;
        Console.WriteLine("Message has violations: {0}", hasViolations.ToString());

        var validationErrors = new List<string>();
        foreach(var violation in violations.Violations)
        {
            Console.WriteLine("Violation: {0}", violation);
            validationErrors.Add(violation.ToString());
        }

        if (hasViolations)
            return Result.Fail(validationErrors);

        return Result.Ok();
    }
}